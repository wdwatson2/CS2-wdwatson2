#include <iostream>
#include "linkedList.h" //list structure of choice
#include "bubbleSort.h"
#include "insertionSort.h"
#include "quickSort.h"
#include <random> //create lists of doubles
#include <chrono> //time sorting algorithms
#include <fstream> //to write output to a file
#include <iomanip>


using namespace std;

// #define DEBUG

const double RANDNUM_MAX = 937017.0;
const double RANDNUM_MIN = 237.0;

int main()
{
    //redirecting cerr stream to write to files
    fstream file, file1, file2, file3;
    file.open("QuickSort.txt", ios::out);
    file1.open("OriginalData.txt", ios::out);
    // file2.open("BubbleSort.txt", ios::out);
    // file3.open("InsertionSort.txt", ios::out);

    streambuf* stream_buffer_cerr = cerr.rdbuf();
    streambuf* stream_buffer_QuickSort = file.rdbuf();
    streambuf* stream_buffer_Original = file1.rdbuf();
    // streambuf* stream_buffer_BubbleSort = file2.rdbuf();
    // streambuf* stream_buffer_InsertionSort = file3.rdbuf();

    // cerr.rdbuf(stream_buffer_file);
 

    // cerr.rdbuf(stream_buffer_cerr); 
    // file.close();


    //create 6 linked lists (4 for quicksort variants, 1 for bubble, 1 for insertion) 
    //of 50,000 random doubles from range of 237 to 937017
    LinkedList<double> * list1;
    list1 = new LinkedList<double>;
    LinkedList<double> * list2;
    list2 = new LinkedList<double>;
    // LinkedList<double> list3;
    // LinkedList<double> list4;
    // LinkedList<double> list5;
    // LinkedList<double> list6;

    // for(int i = 0; i < 50000; i++)
    // {
    //     // srand(i*time(NULL)); //seeding the random number generator with index so I can have new number each iteration

    //     std::uniform_real_distribution<double> unif(RANDNUM_MIN,RANDNUM_MAX);
    //     std::default_random_engine re;
    //     double f = unif(re);
    //     // double f = (double)rand() / RAND_MAX; // 0 < num < 1. So its a decimal
    //     // f = RANDNUM_MIN + f * (RANDNUM_MAX - RANDNUM_MIN); //rand() returns rand int. Extra work to make a double

    //     list1.add(f); //populating each linked list with the same random number 
    //     // list2.add(f); //all lists contain the same numbers in the same order
    //     // list3.add(f);
    //     // list4.add(f);
    //     // list5.add(f);
    //     // list6.add(f);
    // }
    random_device rd;  // Will be used to obtain a seed for the random number engine
    mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()
    uniform_real_distribution<> dis(RANDNUM_MIN, RANDNUM_MAX);
    for (int n = 0; n < 50000; ++n) {
        // Use dis to transform the random unsigned int generated by gen into a 
        // double in [1, 2). Each call to dis(gen) generates a new random double
        double f = dis(gen);
        list1->add(f);
        list2->add(f);
    }

    //writing random nums out to originaldata.txt
    cerr.rdbuf(stream_buffer_Original);
    for(auto indx = list1->begin(); indx != list1->end(); ++indx)
    {
        for(int i = 0; i < 4; i++)
        {
            cerr << *indx << '\t';
            ++indx;
        }
        cerr << *indx << endl;
    }

    //running quickSort and all its variants and writing output to QuickSort.txt
    cerr.rdbuf(stream_buffer_QuickSort); 

    //variation 1 - quicksort with middle as pivot
    int execTimeforQuick;
    quicksort quicksorted;
    auto start = chrono::high_resolution_clock::now(); //start timer

    quicksorted.quicksortMiddle(*list1, 0, list1->getSize()-1, true);

    auto stop = chrono::high_resolution_clock::now();//end timer
    auto duration = chrono::duration_cast<chrono::microseconds>(stop - start); //find difference 
    execTimeforQuick = duration.count();
    
    for(auto indx = list1->begin(); indx != list1->end(); ++indx)
    {
        for(int i = 0; i < 4; i++)
        {
            cerr << *indx << '\t';
            ++indx;
        }
        cerr << *indx << endl;
    }
    
    cerr << endl << "Quick-Sort Variation 1 - Middle Element as Pivot" << endl;
    cerr << "Execution Time: " << execTimeforQuick << " microseconds." << endl;
    cerr << "Number of Comparisons: " << quicksorted.getNumComparisons() << endl;
    cerr << "Number of Swaps: " << quicksorted.getNumSwaps() << endl << endl;

    delete list1;

    cout << "Finished with list1" << endl;

    //variation 2 - quicksort with median as pivot
    // quicksort quicksorted2;
    // start = chrono::high_resolution_clock::now(); //start timer

    // quicksorted2.quicksortMedian(*list2, 0, list2->getSize()-1, true);

    // stop = chrono::high_resolution_clock::now();//end timer
    // duration = chrono::duration_cast<chrono::microseconds>(stop - start); //find difference 
    // execTimeforQuick = duration.count();
    
    // for(auto indx = list2->begin(); indx != list2->end(); ++indx)
    // {
    //     for(int i = 0; i < 4; i++)
    //     {
    //         cerr << *indx << '\t';
    //         ++indx;
    //     }
    //     cerr << *indx << endl;
    // }
    
    // cerr << endl << "Quick-Sort Variation 2 - Median of low, high, and middle as Pivot" << endl;
    // cerr << "Execution Time: " << execTimeforQuick << " microseconds." << endl;
    // cerr << "Number of Comparisons: " << quicksorted2.getNumComparisons() << endl;
    // cerr << "Number of Swaps: " << quicksorted2.getNumSwaps() << endl;

    // delete list2;

    
    
    
    
    cerr.rdbuf(stream_buffer_cerr); 
    file1.close();
    // file2.close();



    // int execTime;
    // quicksort quicksorted;
    // auto start = chrono::high_resolution_clock::now(); //start timer

    // quicksorted.quicksortMedianAndInsertion(list1, 0, list1.getSize()-1, true);

    // auto stop = chrono::high_resolution_clock::now();//end timer
    // auto duration = chrono::duration_cast<chrono::seconds>(stop - start); //find difference 
    // execTime = duration.count();

    // cout << "time: " << execTime << endl;
    // cout << "comparisons: " << quicksorted.getNumComparisons() << endl;
    // cout << "swaps: " << quicksorted.getNumSwaps() << endl;
    // for(auto indx = list1.begin(); indx != list1.end(); ++indx)
    //     cout << *indx << " ";
    // cout << endl;


    // list1.~LinkedList();
    return 0;
}